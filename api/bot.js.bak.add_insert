// api/bot.js ‚Äî v1.1.7 (variants)
// NOTE: This file replaces legacy ‚Äúunit√© + 2 prix‚Äù with optional ‚Äúquantities[]‚Äù variants.
// - Add Product: ask if using variants (yes/no). If yes, collect (label;cash;crypto) lines.
// - Edit Product: new ‚ÄúVariantes (JSON)‚Äù option to paste a JSON array [{label,price_cash,price_crypto}, ...].
// - Product list: shows variants if present.
// - Reports/order recap already support variantLabel (order.js).

const axios = require('axios');
const { kv } = require('@vercel/kv');
// --- admin session (KV) ---
const ADMIN_SESS_PREFIX = 'admin:sess:';
async function adminSessionGet(uid){ try{ return (await kv.get(ADMIN_SESS_PREFIX+uid)) || null; }catch(_){ return null; } }
async function adminSessionSet(uid, obj){ try{ await kv.set(ADMIN_SESS_PREFIX+uid, obj); }catch(_){ } }
async function adminSessionClear(uid){ try{ await kv.del(ADMIN_SESS_PREFIX+uid); }catch(_){ } }

function prettyErr(e){
  try{
    if (e && e.response){
      const status = e.response.status;
      let payload = e.response.data;
      if (typeof payload !== 'string') payload = JSON.stringify(payload);
      if (payload && payload.length > 1200) payload = payload.slice(0,1200) + '‚Ä¶';
      return 'HTTP '+status+' ‚Äî '+payload;
    }
    return String(e && e.message || e);
  }catch(_){ return String(e); }
}
const { preview, apply, rollback, currentDataVersion } = require('./_patchEngine');
const PATCH_SECRET = '';
const BOT = () => {
  const token = process.env.TELEGRAM_BOT_TOKEN;
  return axios.create({ baseURL: `https://api.telegram.org/bot${token}` });
};

module.exports = async (req, res) => {
  try {
    if (req.method !== 'POST') { res.statusCode = 405; return res.end('Method Not Allowed'); }
    const secretHeader = req.headers['x-telegram-bot-api-secret-token'];
    if (process.env.TELEGRAM_WEBHOOK_SECRET && secretHeader && secretHeader !== process.env.TELEGRAM_WEBHOOK_SECRET) {
      res.statusCode = 401; return res.end('Unauthorized');
    }
    const update = await readJson(req);
    try { const t = update.callback_query?'callback_query':(update.message?'message':'?'); console.log('[BOT] update type=', t, 'keys=', Object.keys(update||{})); } catch(_){}
    if (update.callback_query) {
      await onCallbackQuery(update.callback_query);
    } else if (update.message) {
      await onMessage(update.message);
    }
    res.statusCode = 200; res.end('OK');
  } catch { res.statusCode = 200; res.end('OK'); }
};

async function readJson(req) {
  return new Promise((resolve) => {
    let data=''; req.on('data',c=>data+=c); req.on('end',()=>{ try{resolve(JSON.parse(data||'{}'))}catch{resolve({})} });
  });
}
function isAdmin(userId, settings) { const list=settings?.admins||[]; return list.includes(String(userId)); }
async function send(text, chat_id, inlineKb, plain=false){
  return BOT().post('/sendMessage',{ chat_id, text, parse_mode: plain?undefined:'HTML', disable_web_page_preview:true, reply_markup: inlineKb ? { inline_keyboard: inlineKb } : undefined });
}
function userHomeKb(){
  const webappUrl=process.env.WEBAPP_URL;
  return { keyboard:[ [{text:'Description'},{text:'FAQ'}], [{text:'Menu', web_app:{url:webappUrl}}] ], resize_keyboard:true };
}
async function sendHome(chatId){
  await BOT().post('/sendMessage',{ chat_id:chatId, text:'Bienvenue ! Choisis une option :', reply_markup: userHomeKb() });
}
async function getFileUrl(fileId){
  const r=await BOT().get('/getFile',{ params:{ file_id:fileId }});
  const path=r.data?.result?.file_path; const token=process.env.TELEGRAM_BOT_TOKEN;
  if (!path) return null; return `https://api.telegram.org/file/bot${token}/${path}`;
}

/** ===== Menus Admin ===== **/
function adminRootKb(){
  return [
    [{ text:'üõí Produits', callback_data:'admin:cat_products' }],
    [{ text:'üìù Textes', callback_data:'admin:cat_texts' }],
    [{ text:'üé® Branding', callback_data:'admin:cat_branding' }],
    [{ text:'üîê Acc√®s', callback_data:'admin:cat_access' }],
    [{ text:'üì¶ Formulaire', callback_data:'admin:cat_form' }],
    [{ text:'üìû Contact', callback_data:'admin:cat_contact' }],
    [{ text:'üëë Admins', callback_data:'admin:cat_admins' }],
    [{ text:'üìà Rapports', callback_data:'admin:cat_reports' }],
    [{ text:'üß© Patchs', callback_data:'admin:cat_patches' }]
  ];
}

function adminProductsKb(){
  return [
    [{ text:'üìã Lister', callback_data:'admin:prod_list' }],
    [{ text:'‚ûï Ajouter', callback_data:'admin:add_product' }],
    [{ text:'‚úèÔ∏è Modifier', callback_data:'admin:edit_product' }],
    [{ text:'üóëÔ∏è Supprimer', callback_data:'admin:delete_product' }],
    [{ text:'‚¨ÖÔ∏è Retour', callback_data:'admin:root' }]
  ];
}
function adminTextsKb(){
  return [
    [{ text:'‚úèÔ∏è Description', callback_data:'admin:set_description' }],
    [{ text:'‚úèÔ∏è FAQ', callback_data:'admin:set_faq' }],
    [{ text:'‚¨ÖÔ∏è Retour', callback_data:'admin:root' }]
  ];
}
function adminBrandingKb(){
  return [
    [{ text:'üñºÔ∏è Logo', callback_data:'admin:set_logo' }, { text:'üñºÔ∏è Fond', callback_data:'admin:set_bg' }],
    [{ text:'‚ôªÔ∏è Revenir au fond par d√©faut', callback_data:'admin:reset_bg' }],
    [{ text:'üè∑Ô∏è Nom boutique', callback_data:'admin:set_name' }],
    [{ text:'‚¨ÖÔ∏è Retour', callback_data:'admin:root' }]
  ];
}
function adminAccessKb(){
  return [
    [{ text:'Rendre PUBLIC', callback_data:'admin:set_access:public' }],
    [{ text:'Rendre PRIV√â', callback_data:'admin:set_access:private' }],
    [{ text:'Canaux priv√©s (ajouter/supprimer)', callback_data:'admin:channels_manage' }],
    [{ text:'‚¨ÖÔ∏è Retour', callback_data:'admin:root' }]
  ];
}
function adminFormKb(fields){
  const f=fields||{};
  return [
    [{ text:`Pr√©nom: ${f.firstname?'‚úÖ':'‚ùå'}`, callback_data:'admin:form_toggle:firstname' }, { text:`Nom: ${f.lastname?'‚úÖ':'‚ùå'}`, callback_data:'admin:form_toggle:lastname' }],
    [{ text:`Adresse: ${f.address1?'‚úÖ':'‚ùå'}`, callback_data:'admin:form_toggle:address1' }],
    [{ text:`CP: ${f.postalCode?'‚úÖ':'‚ùå'}`, callback_data:'admin:form_toggle:postalCode' }, { text:`Ville: ${f.city?'‚úÖ':'‚ùå'}`, callback_data:'admin:form_toggle:city' }],
    [{ text:`Pays: ${f.country?'‚úÖ':'‚ùå'}`, callback_data:'admin:form_toggle:country' }],
    [{ text:'üîÅ R√©initialiser', callback_data:'admin:form_reset' }],
    [{ text:'‚¨ÖÔ∏è Retour', callback_data:'admin:root' }]
  ];
}
function adminContactKb(){
  return [
    [{ text:'‚úèÔ∏è Contact Telegram', callback_data:'admin:set_contact' }],
    [{ text:'‚¨ÖÔ∏è Retour', callback_data:'admin:root' }]
  ];
}
function adminAdminsKb(){
  return [
    [{ text:'üìã Lister', callback_data:'admin:admins_list' }],
    [{ text:'‚ûï Ajouter', callback_data:'admin:admin_add' }, { text:'üóëÔ∏è Retirer', callback_data:'admin:admin_remove' }],
    [{ text:'‚¨ÖÔ∏è Retour', callback_data:'admin:root' }]
  ];
}
function kbConfirm(extra=[]) {
  return [[
    { text:'‚úÖ Valider', callback_data:'ok' },
    { text:'üîÑ Revenir', callback_data:'back' },
    { text:'‚úñÔ∏è Annuler', callback_data:'cancel' },
    ...extra
  ]];
}
function kbMedia(){
  return [[
    { text:'‚ûï Ajouter d‚Äôautres m√©dias', callback_data:'more_media' },
    { text:'üßπ Vider m√©dias', callback_data:'clear_media' },
    { text:'‚û°Ô∏è Terminer', callback_data:'finish_media' }
  ],[
    { text:'‚úñÔ∏è Annuler', callback_data:'cancel' }
  ]];
}

function adminPatchesKb(showUpgrade){
  const base = [
    [{ text:'üì• Appliquer un patch', callback_data:'admin:patch_wait' }],
    [{ text:'üìú Historique', callback_data:'admin:patch_history' }],
    [{ text:'üßæ Version', callback_data:'admin:version' }],
    [{ text:'‚¨ÖÔ∏è Retour', callback_data:'admin:root' }]
  ];
  if (showUpgrade) base.splice(2, 0, [{ text:'üöÄ Upgrade', callback_data:'admin:upgrade' }]);
  return base;
}

/** ===== Callbacks ===== **/
async function onCallbackQuery(cbq){
  const chatId=cbq.message?.chat?.id; const userId=cbq.from?.id; const data=cbq.data||'';
  try { await BOT().post('/answerCallbackQuery',{ callback_query_id: cbq.id }); } catch (_) {}
  let settings=await kv.get('settings');
  if (!settings){ settings={admins:[String(userId)]}; await kv.set('settings', settings); }
  if (!isAdmin(userId, settings)) { await send('Acc√®s admin requis.', chatId, null, true); return; }

  // Root & cat√©gories
  if (data==='admin:root'){ await send('Panneau admin :', chatId, adminRootKb()); return; }
  if (data==='admin:cat_products'){ await send('Produits :', chatId, adminProductsKb()); return; }
  if (data==='admin:cat_texts'){ await send('Textes :', chatId, adminTextsKb()); return; }
  if (data==='admin:cat_branding'){ await send('Branding :', chatId, adminBrandingKb()); return; }
  if (data==='admin:cat_access'){ await send('Acc√®s :', chatId, adminAccessKb()); return; }
  if (data==='admin:cat_form'){
    const fields = (settings.deliveryForm?.fields) || {};
    await send('Formulaire de livraison (activer/d√©sactiver champs) :', chatId, adminFormKb(fields)); return;
  }
  if (data==='admin:cat_contact'){ await send('Contact :', chatId, adminContactKb()); return; }
  if (data==='admin:cat_admins'){ await send('Admins :', chatId, adminAdminsKb()); return; }

  // Patchs
  if (data==='admin:cat_patches'){
    const sess = await adminSessionGet(userId);
    const showUp = !!(sess && sess.flow==='patch' && sess.step==='applied');
    await send('üß© Patchs :', chatId, adminPatchesKb(showUp));
    return;
  }
  if (data==='admin:version'){ await handleVersion(chatId); return; }
  if (data==='admin:patch_wait'){
    await adminSessionSet(userId,{ flow:'patch', step:'wait_doc' });
    await send('Envoie le fichier JSON du patch (comme *Document*).', chatId, adminPatchesKb(false));
    return;
  }
  if (data==='admin:patch_history'){
    try{
      const hist = (await kv.get('patch:history')) || [];
      if (!hist.length){ await send('Aucun patch appliqu√© pour le moment.', chatId, adminPatchesKb(false)); return; }
      const lines = hist.slice(-10).map(h=>`‚Ä¢ ${h.at||'-'} : ${h.from||'?'} ‚Üí ${h.to||'?'} ${h.rollback?'(rollback)':''}`).join('\n');
      await send(`<b>Derniers patchs</b>\n${lines}`, chatId, adminPatchesKb(true));
    }catch(e){ await send('Erreur historique: '+(e&&e.message||e), chatId); }
    return;
  }

  // Rapports
  if (data==='admin:cat_reports'){ await send('üìà Rapports ‚Äî choisis une p√©riode :', chatId, adminReportsKb()); return; }
  if (data.startsWith('admin:reports:range:')){
    try {
      const kind = data.split(':').pop();
      await handleReports(chatId, kind);
    } catch (e) {
      await send('Erreur rapports: ' + String(e && e.message || e), chatId);
    }
    return;
  }

  // Produits ‚Äî LISTE (compat variantes)
  if (data==='admin:prod_list'){
    const products=(await kv.get('products'))||[];
    if (!products.length){ await send('<b>Produits actifs</b>\n\n(aucun)', chatId, adminProductsKb()); return; }
    const blocks=products.map(p=>{
      const mediaCount=(p.media||[]).length;
      if (Array.isArray(p.quantities) && p.quantities.length){
        const qs = p.quantities.map(v=>{
          const lb=String(v?.label||''); const pc=Number(v?.price_cash||0); const pr=Number(v?.price_crypto||0);
          return `  - ${lb}: ${pc} ‚Ç¨ / ${pr} ‚Ç¨`;
        }).join('\n');
        return `‚Ä¢ <b>${p.name}</b> (${p.id})\nTarifs:\n${qs}\nM√©dias: ${mediaCount}\nDesc: ${p.description||'-'}`;
      } else {
        const unit=p.unit||'1u'; const pc=Number(p.price_cash||0); const pr=Number(p.price_crypto||0);
        return `‚Ä¢ <b>${p.name}</b> (${p.id})\nTarif: ${unit} ‚Äî ${pc} ‚Ç¨ / ${pr} ‚Ç¨\nM√©dias: ${mediaCount}\nDesc: ${p.description||'-'}`;
      }
    }).join('\n\n');
    await send(`<b>Produits actifs</b>\n\n${blocks}`, chatId, adminProductsKb()); return;
  }

  // Produits ‚Äî AJOUT
  if (data==='admin:add_product'){
    await adminSessionSet(userId,{ flow:'add_product', step:'name', payload:{ media:[], quantities:[] } });
    await send('Nom du produit ?', chatId); return;
  }

  // Produits ‚Äî EDIT (ajoute Variantes JSON)
  if (data==='admin:edit_product'){
    await adminSessionSet(userId,{ flow:'edit_product', step:'ask_id' });
    await send('ID ou nom du produit √† modifier ?', chatId); return;
  }
  if (data.startsWith('admin:edit_field:')){
    const field = data.split(':')[2];
    const sess=await adminSessionGet(userId);
    if (!sess || sess.flow!=='edit_product' || !sess.payload?.id) return;
    if (field==='media'){
      sess.step='media'; sess.payload.newMedia=[]; await adminSessionSet(userId, sess);
      await send('Envoie des <b>photos/vid√©os</b>.\nTu peux vider d‚Äôabord les m√©dias existants avec üßπ puis ajouter.\nQuand c‚Äôest bon : ‚û°Ô∏è Terminer.', chatId, kbMedia());
    } else if (field==='variants_json'){
      sess.step='variants_json'; await adminSessionSet(userId, sess);
      await send('Colle le JSON des variantes (ex: [{"label":"10g","price_cash":5,"price_crypto":6}]).', chatId, kbConfirm());
    } else {
      sess.step='field_val'; sess.payload.field=field; await adminSessionSet(userId, sess);
      const labelMap={name:'Nom',description:'Description',unit:'Unit√©',price_cash:'Prix cash (‚Ç¨)',price_crypto:'Prix crypto (‚Ç¨)'};
      await send(`${labelMap[field]||field} ?`, chatId, kbConfirm());
    }
    return;
  }

  // Supprimer un produit
  if (data==='admin:delete_product'){
    await adminSessionSet(userId,{ flow:'delete_product', step:'ask', payload:{} });
    await send('ID ou nom du produit √† supprimer ?', chatId); return;
  }

  // Textes
  if (data==='admin:set_description'){
    await adminSessionSet(userId,{ flow:'set_description', step:'text' });
    await send('Envoie la <b>Description</b> compl√®te.', chatId); return;
  }
  if (data==='admin:set_faq'){
    await adminSessionSet(userId,{ flow:'set_faq', step:'text' });
    await send('Envoie la <b>FAQ</b> compl√®te.', chatId); return;
  }

  // Branding
  if (data==='admin:set_logo'){
    await adminSessionSet(userId,{ flow:'set_logo', step:'wait_media' });
    await send('Envoie une <b>photo</b> pour le logo.', chatId); return;
  }
  if (data==='admin:set_bg'){
    await adminSessionSet(userId,{ flow:'set_bg', step:'wait_media' });
    await send('Envoie une <b>photo</b> pour le fond d‚Äô√©cran.', chatId); return;
  }
  if (data==='admin:reset_bg'){
    const s=(await kv.get('settings'))||{}; delete s.bgUrl; await kv.set('settings', s);
    await send('‚úÖ Fond d‚Äô√©cran r√©initialis√© (valeur par d√©faut).', chatId, adminBrandingKb()); return;
  }
  if (data==='admin:set_name'){
    await adminSessionSet(userId,{ flow:'set_name', step:'ask' });
    await send('Nom de la boutique ?', chatId); return;
  }

  // Acc√®s (public/priv√© + canaux)
  if (data==='admin:set_access:public' || data==='admin:set_access:private'){
    settings.privateMode = data.endsWith(':private');
    await kv.set('settings', settings);
    await send(`Mode d'acc√®s d√©fini: <b>${settings.privateMode ? 'Priv√©' : 'Public'}</b>`, chatId, adminAccessKb()); return;
  }
  if (data==='admin:channels_manage'){
    await adminSessionSet(userId,{ flow:'channels', step:'menu' });
    const list = (settings.channels||[]).join('\n‚Ä¢ ');
    await send(`Canaux priv√©s:\n${list? '‚Ä¢ '+list : '(aucun)'}\n\nEnvoyer @canal pour ajouter, ou "supprimer @canal" pour retirer.`, chatId); return;
  }

  // Formulaire (toggle champs)
  if (data.startsWith('admin:form_toggle:')){
    const key = data.split(':').pop();
    settings.deliveryForm = settings.deliveryForm || { fields:{} };
    settings.deliveryForm.fields = settings.deliveryForm.fields || {};
    settings.deliveryForm.fields[key] = !settings.deliveryForm.fields[key];
    await kv.set('settings', settings);
    await send('Formulaire mis √† jour :', chatId, adminFormKb(settings.deliveryForm.fields)); return;
  }
  if (data==='admin:form_reset'){
    settings.deliveryForm = { fields: { firstname:true, lastname:true, address1:true, postalCode:true, city:true, country:true } };
    await kv.set('settings', settings);
    await send('‚úÖ Formulaire r√©initialis√©.', chatId, adminFormKb(settings.deliveryForm.fields)); return;
  }

  // Contact
  if (data==='admin:set_contact'){
    await adminSessionSet(userId,{ flow:'set_contact', step:'ask' });
    await send('Envoie le @username du contact (sans lien).', chatId); return;
  }

  // Admins
  if (data==='admin:admins_list'){
    const admins = (settings.admins||[]).map(id=>'‚Ä¢ '+id).join(
) || '(aucun)';
    await send('<b>Admins</b>\n'+admins, chatId, adminAdminsKb()); return;
  }
  if (data==='admin:admin_add'){
    await adminSessionSet(userId,{ flow:'admins', step:'add' });
    await send('Envoie l‚ÄôID num√©rique Telegram de l‚Äôadmin √† ajouter.', chatId); return;
  }
  if (data==='admin:admin_remove'){
    await adminSessionSet(userId,{ flow:'admins', step:'remove' });
    await send('Envoie l‚ÄôID num√©rique Telegram de l‚Äôadmin √† retirer.', chatId); return;
  }
  // Media helpers
  const sess=await adminSessionGet(userId);
  if (data==='more_media'){
    if (sess && (sess.flow==='add_product' || (sess.flow==='edit_product' && sess.step==='media'))) {
      await adminSessionSet(userId, {...sess, step:'media'});
      await send('Envoie d‚Äôautres <b>photos/vid√©os</b>.\nQuand c‚Äôest bon : ‚û°Ô∏è Terminer.', chatId, kbMedia());
    }
    return;
  }
  if (data==='clear_media'){
    if (sess?.flow==='edit_product' && sess.step==='media'){
      sess.payload.clearFirst = true;
      sess.payload.newMedia = [];
      await adminSessionSet(userId, sess);
      await send('üßπ M√©dias existants seront vid√©s. Ajoute maintenant les nouveaux, puis ‚û°Ô∏è Terminer.', chatId, kbMedia());
    }
    return;
  }
  if (data==='finish_media'){
    if (sess?.flow==='add_product'){
      const p=sess.payload;
      const recap=[
        `‚Ä¢ Nom: ${p.name}`,
        `‚Ä¢ Desc: ${p.description}`,
        ...(Array.isArray(p.quantities)&&p.quantities.length ? [
          `‚Ä¢ Variantes:`,
          ...(p.quantities.map(v=>`   - ${v.label}: ${v.price_cash} ‚Ç¨ / ${v.price_crypto} ‚Ç¨`))
        ] : [
          `‚Ä¢ Unit√©: ${p.unit}`,
          `‚Ä¢ Cash: ${p.price_cash} ‚Ç¨ | Crypto: ${p.price_crypto} ‚Ç¨`,
        ]),
        `‚Ä¢ M√©dias: ${p.media?.length||0}`
      ].join('\n');
      await adminSessionSet(userId, {...sess, step:'confirm'});
      await send(`<b>R√©cap</b>\n${recap}`, chatId, kbConfirm());
    } else if (sess?.flow==='edit_product' && sess.step==='media'){
      const products=(await kv.get('products'))||[];
      const idx=products.findIndex(p=>p.id===sess.payload.id);
      if (idx<0){ await send('Produit introuvable.', chatId); return; }
      if (sess.payload.clearFirst) products[idx].media = [];
      products[idx].media = products[idx].media || [];
      products[idx].media.push(...(sess.payload.newMedia||[]));
      await kv.set('products', products);
      await adminSessionClear(userId);
      await send('‚úÖ M√©dias du produit mis √† jour.', chatId, adminProductsKb());
    }
    return;
  }

  // Confirmations g√©n√©riques
  if (data==='ok'){
    const sess=await adminSessionGet(userId);
    if (sess?.flow==='add_product' && sess.step==='confirm'){
      const products=(await kv.get('products'))||[];
      const p=sess.payload; p.id=p.id||('p'+Math.random().toString(36).slice(2,8)); p.media=p.media||[];
      products.push(p); await kv.set('products', products);
      await adminSessionClear(userId);
      await send('‚úÖ Produit ajout√©.', chatId, adminProductsKb()); return;
    }
    if (sess?.flow==='delete_product' && sess.step==='confirm'){
      let products=(await kv.get('products'))||[]; const before=products.length;
      products=products.filter(x=>x.id!==sess.payload.id); await kv.set('products', products);
      await adminSessionClear(userId);
      await send(before===products.length?'Aucun produit supprim√©.':'‚úÖ Produit supprim√©.', chatId, adminProductsKb()); return;
    }
  }
  if (data==='back'){
    const sess=await adminSessionGet(userId);
    if (sess?.flow==='add_product'){
      if (sess.step==='confirm'){ await adminSessionSet(userId,{...sess, step:'media'}); await send('Envoie 1 ou plusieurs m√©dias, puis ‚û°Ô∏è Terminer.', chatId, kbMedia()); }
      else if (sess.step==='media'){
        if (Array.isArray(sess.payload.quantities) && sess.payload.quantities.length){
          await adminSessionSet(userId,{...sess, step:'variants'}); await send('Ajoute des variantes (label;cash;crypto) ‚Äî "fin" pour terminer.', chatId);
        } else {
          await adminSessionSet(userId,{...sess, step:'ask_variants'}); await send('Utiliser des variantes ? (oui/non)', chatId);
        }
      }
      else if (sess.step==='variants'){ await adminSessionSet(userId,{...sess, step:'ask_variants'}); await send('Utiliser des variantes ? (oui/non)', chatId); }
      else if (sess.step==='ask_variants'){ await adminSessionSet(userId,{...sess, step:'desc'}); await send('Description ?', chatId); }
      else if (sess.step==='desc'){ await adminSessionSet(userId,{...sess, step:'name'}); await send('Nom du produit ?', chatId); }
      return;
    }
  }
  if (data==='cancel'){ await adminSessionClear(userId); await send('‚úñÔ∏è Flow annul√©.', chatId, adminRootKb()); return; }
}

/** ===== Messages ===== **/
async function onMessage(msg){
// ---- DIAG DOC ----
  try {
    console.log('[BOT] onMessage keys=', Object.keys(msg||{}));
    if (msg && msg.document) {
      const name = (msg.document.file_name||'inconnu');
      try { await send('üìÑ Doc re√ßu: '+name+' ‚Äî traitement‚Ä¶', msg.chat.id); } catch(_){}
    }
  } catch(_){}

  // Rattrapage: si un ADMIN envoie un document, on traite le patch directement
  try{
    if (msg && msg.document){
      const s = (await kv.get('settings')) || {};
      if (isAdmin(msg.from?.id, s)) { await handlePatchDocument(msg); return; }
    }
  }catch(_){/* ignore */}
  // --- Raccourcis commandes ---
  if (msg && msg.document && (msg.caption||"").trim()==="/patch") { await handlePatchDocument(msg); return; }
  if (msg && msg.text && msg.text.startsWith("/rollback ")) { const v=(msg.text||"").split(" ")[1]; await handleRollback(msg.chat.id, msg.from.id, v); return; }
  if (msg && msg.text && (msg.text||"").trim()==="/version") { await handleVersion(msg.chat.id); return; }
  if (msg && msg.text && (msg.text||"").trim()==="/upgrade") { await handleUpgrade(msg.chat.id, msg.from.id); return; }

  // --- Mode 'Appliquer un patch' : accepte Document OU JSON en texte ---
  try{
    const __sessPatch = await adminSessionGet(msg.from.id);
    if (__sessPatch && __sessPatch.flow==='patch' && __sessPatch.step==='wait_doc'){
      if (msg.document){
        await handlePatchDocument(msg);
        await adminSessionClear(msg.from.id);
        return;
      }
      if (typeof msg.text==='string'){
        const t = msg.text.trim();
        if (t.startsWith('{') && t.endsWith('}')){
          try{
            const manifest = JSON.parse(t);
            const p = await preview(manifest, PATCH_SECRET);
            await send(`PREVIEW OK\n${p.summary}\nCurrent: ${p.currentVersion}\nKeys: ${p.willWriteKeys.join(', ')}`, msg.chat.id);
            const r = await apply(manifest, String(msg.from.id), PATCH_SECRET);
            await send(`Patch applied. Backup: backup:${manifest.version}`, msg.chat.id);
            await adminSessionSet(msg.from.id,{ flow:'patch', step:'applied' });
            await send('Patch appliqu√©. Tu peux lancer un üöÄ Upgrade si besoin.', msg.chat.id, adminPatchesKb(true));
            return;
          }catch(e){
            await send('Patch error (text): ' + (e && e.message || e), msg.chat.id);
            return;
          }
        }
      }
    }
  }catch(_){}

  // --- Flux standard ---
  const chatId=msg.chat?.id; const fromId=msg.from?.id; let text=(msg.text||'').trim();

  let settings=await kv.get('settings');
  if (!settings){
    settings = {
      shopName:'Boutique',
      description:'Bienvenue dans la boutique. Produits d√©mo.',
      faq:'Q: Livraison ?\nR: Par colis.\n\nQ: Paiement ?\nR: Cash ou crypto (redirig√© vers contact humain en V1).',
      contactUsername:'TonContactHumain',
      privateMode:false, requiredChannel:'', channels:[],
      admins:[ String(fromId) ],
      deliveryForm:{ fields:{ firstname:true, lastname:true, address1:true, postalCode:true, city:true, country:true } }
    };
    await kv.set('settings', settings);
  }

  if (['/start','FAQ','Description','Menu','/faq','/description','/menu'].includes(text)) {
    await adminSessionClear(fromId);
    if (text==='/start' || text==='Menu' || text==='/menu') { await sendHome(chatId); return; }
    if (text==='FAQ' || text==='/faq') { await send(settings.faq||'‚Äî', chatId); return; }
    if (text==='Description' || text==='/description') { await send(settings.description||'‚Äî', chatId); return; }
    return;
  }

  if (text==='/cancel'){ await adminSessionClear(fromId); await send('Flow annul√©.', chatId); return; }

  if (text==='/admin'){
    if (!Array.isArray(settings.admins)||settings.admins.length===0){ settings.admins=[String(fromId)]; await kv.set('settings', settings); }
    if (!isAdmin(fromId, settings)) { await send('Acc√®s admin requis.', chatId); return; }
    await send('Panneau admin :', chatId, adminRootKb()); return;
  }

  const sess=await adminSessionGet(fromId);
  if (sess){ await handleAdminFlowStep(msg, sess); return; }

  await sendHome(chatId);
}

async function handleAdminFlowStep(msg, sess){
  const chatId=msg.chat.id; const userId=msg.from.id;

  // === ADD PRODUCT (with variants option) ===
  if (sess.flow==='add_product'){
    if (sess.step==='name' && msg.text){ sess.payload.name=msg.text.trim(); sess.step='desc'; await adminSessionSet(userId,sess); await send('Description ?', chatId); return; }
    if (sess.step==='desc' && msg.text){
  sess.payload.description = msg.text.trim();
  // √âtape variantes JSON (ou "aucune" pour garder unit√©/prix uniques)
  sess.step='variants_json_add'; await adminSessionSet(userId, sess);
  await send('Envoie les variantes au format JSON (ex: [\n  {"label":"10g","price_cash":5,"price_crypto":6}\n])\nOu tape "aucune" pour utiliser unit√©/prix uniques.', chatId);
  return;
}

    if (sess.step==='ask_variants' && msg.text){
      const t = msg.text.trim().toLowerCase();
      if (['oui','yes','o','y'].includes(t)){ sess.step='variants'; await adminSessionSet(userId,sess); await send('Envoie des variantes, une par ligne, au format: <b>label;cash;crypto</b>\nEx:\n10g;5;6\n50g;20;24\n\nTape "fin" quand termin√©.', chatId); return; }
      if (['non','no','n'].includes(t)){ sess.step='media'; await adminSessionSet(userId,sess); await send('Envoie 1 ou plusieurs <b>photos/vid√©os</b> du produit.\nQuand c‚Äôest bon : ‚û°Ô∏è Terminer.', chatId, kbMedia()); return; }
      await send('R√©ponds "oui" ou "non".', chatId); return;
    }
    if (sess.step==='variants' && msg.text){
      const t = msg.text.trim();
      if (t.toLowerCase()==='fin'){
        if (!(Array.isArray(sess.payload.quantities)&&sess.payload.quantities.length)){
          await send('Aucune variante. R√©ponds par au moins une ligne (label;cash;crypto) ou tape "non" pour revenir sans variantes.', chatId);
          return;
        }
        sess.step='media'; await adminSessionSet(userId,sess);
        await send('Envoie 1 ou plusieurs <b>photos/vid√©os</b> du produit.\nQuand c‚Äôest bon : ‚û°Ô∏è Terminer.', chatId, kbMedia()); return;
      }
      // Parse lines
      const lines = t.split(/\r?\n/).map(s=>s.trim()).filter(Boolean);
      let ok=0, bad=0;
      for (const line of lines){
        const parts=line.split(';').map(s=>s.trim());
        if (parts.length>=3){
          const label=parts[0];
          const pc=Number(parts[1].replace(',','.')); const pr=Number(parts[2].replace(',','.'));
          if (label && isFinite(pc) && isFinite(pr)){
            (sess.payload.quantities ||= []).push({label, price_cash:pc, price_crypto:pr});
            ok++; continue;
          }
        }
        bad++;
      }
      await adminSessionSet(userId,sess);
      await send(`Variantes ajout√©es: ${ok}${bad?` ‚Äî ignor√©es: ${bad}`:''}\nTu peux en rajouter ou taper "fin".`, chatId);
      return;
    }
    if (sess.step==='media'){
      let added=0;
      if (msg.photo?.length){ const best=msg.photo[msg.photo.length-1]; const url=await getFileUrl(best.file_id); if (url){ (sess.payload.media ||= []).push({type:'photo', url}); added++; } }
      if (msg.video){ const url=await getFileUrl(msg.video.file_id); if (url){ (sess.payload.media ||= []).push({type:'video', url}); added++; } }
      if (added>0){ await adminSessionSet(userId, sess); await send(`M√©dia ajout√©. Total: ${sess.payload.media.length}\nTu peux en ajouter d‚Äôautres ou cliquer ‚û°Ô∏è Terminer.`, chatId, kbMedia()); }
      return;
    }
  }

  // === EDIT PRODUCT (adds variants_json) ===
  if (sess.flow==='edit_product'){
    const products=(await kv.get('products'))||[];
    if (sess.step==='ask_id' && msg.text){
      const q=msg.text.trim().toLowerCase();
      const found=products.find(x => x.id.toLowerCase()===q || x.name.toLowerCase()===q);
      if (!found){ await send('Introuvable. R√©essaie avec ID ou nom exact.', chatId); return; }
      sess.payload={ id:found.id };
      sess.step='choose_field';
      await adminSessionSet(userId, sess);
      const kb=[
        [{text:'Nom', callback_data:'admin:edit_field:name'}, {text:'Description', callback_data:'admin:edit_field:description'}],
        [{text:'Variantes (JSON)', callback_data:'admin:edit_field:variants_json'}],
        [{text:'Unit√© (legacy)', callback_data:'admin:edit_field:unit'}],
        [{text:'Prix cash (legacy)', callback_data:'admin:edit_field:price_cash'}, {text:'Prix crypto (legacy)', callback_data:'admin:edit_field:price_crypto'}],
        [{text:'M√©dias', callback_data:'admin:edit_field:media'}],
        [{text:'Annuler', callback_data:'cancel'}]
      ];
      await send(`Modifier <b>${found.name}</b> (${found.id}) ‚Äî choisis le champ :`, chatId, kb);
      return;
    }
    if (sess.step==='variants_json' && msg.text){
      try{
        const arr = JSON.parse(msg.text.trim());
        if (!Array.isArray(arr)) throw new Error('JSON attendu: tableau');
        const clean = arr.map(v=>({ label:String(v?.label||''), price_cash:Number(v?.price_cash||0), price_crypto:Number(v?.price_crypto||0) }))
                        .filter(v=>v.label && isFinite(v.price_cash) && isFinite(v.price_crypto));
        const products=(await kv.get('products'))||[];
        const idx = products.findIndex(p=>p.id===sess.payload.id);
        if (idx<0){ await send('Introuvable.', chatId); return; }
        
    // Raccourci texte pour variantes
    if (sess.step==='choose_field' && msg.text && String(msg.text).trim().toLowerCase()==='/variants'){
      sess.step='variants_json'; await adminSessionSet(userId, sess);
      await send('Colle le JSON des variantes (ex: [{"label":"10g","price_cash":5,"price_crypto":6}]).', chatId, kbConfirm());
      return;
    }
  products[idx].quantities = clean;
        await kv.set('products', products);
        await adminSessionClear(userId); await send('‚úÖ Variantes mises √† jour.', chatId, adminProductsKb()); return;
      }catch(e){
        await send('JSON invalide: '+String(e&&e.message||e), chatId, kbConfirm());
        return;
      }
    }
    // --- Variantes (JSON) ---
    if (sess.step==='variants_json' && msg.text){
      try{
        const arr = JSON.parse(String(msg.text).trim());
        if(!Array.isArray(arr)) throw new Error('Array attendu');
        const products=(await kv.get('products'))||[];
        const idx = products.findIndex(p=>p.id===sess.payload.id);
        if (idx<0){ await send('Introuvable.', chatId); return; }
        products[idx].quantities = arr.map(v=>({
          label: String(v?.label||''),
          price_cash: Number(v?.price_cash||0),
          price_crypto: Number(v?.price_crypto||0)
        })).filter(v=>v.label);
        await kv.set('products', products);
        await adminSessionClear(userId);
        await send('‚úÖ Variantes mises √† jour.', chatId, adminProductsKb()); return;
      }catch(e){
        await send('JSON invalide: '+(e&&e.message||e), chatId); return;
      }
    }
  
    if (sess.step==='field_val' && msg.text){
      const products=(await kv.get('products'))||[];
      const idx = products.findIndex(p=>p.id===sess.payload.id);
      if (idx<0){ await send('Introuvable.', chatId); return; }
      const field = sess.payload.field;
      const val = msg.text.trim();
      const p = products[idx];
      if (field==='price_cash' || field==='price_crypto'){ p[field] = Number(val.replace(',','.'))||0; }
      else { p[field] = val; }
      products[idx]=p; await kv.set('products', products);
      await adminSessionClear(userId); await send('‚úÖ Produit modifi√©.', chatId, adminProductsKb()); return;
    }
    if (sess.step==='media'){
      let added=0;
      if (msg.photo?.length){ const best=msg.photo[msg.photo.length-1]; const url=await getFileUrl(best.file_id); if (url){ (sess.payload.newMedia ||= []).push({type:'photo', url}); added++; } }
      if (msg.video){ const url=await getFileUrl(msg.video.file_id); if (url){ (sess.payload.newMedia ||= []).push({type:'video', url}); added++; } }
      if (added>0){ await adminSessionSet(userId, sess); await send(`M√©dia ajout√©. Nouveaux en attente: ${(sess.payload.newMedia||[]).length}\nTu peux en ajouter d‚Äôautres ou ‚û°Ô∏è Terminer.`, chatId, kbMedia()); }
      return;
    }
  }

  // === DELETE PRODUCT ===
  if (sess.flow==='delete_product'){
    if (sess.step==='ask' && msg.text){
      const q=msg.text.trim().toLowerCase(); const products=(await kv.get('products'))||[];
      const found=products.find(x=>x.id.toLowerCase()===q || x.name.toLowerCase()===q);
      if (!found){ await send('Introuvable. R√©essaie avec ID ou nom exact.', chatId); return; }
      await adminSessionSet(userId,{ flow:'delete_product', step:'confirm', payload:{ id:found.id, name:found.name } });
      await send(`Supprimer <b>${found.name}</b> (${found.id}) ?`, chatId, kbConfirm()); return;
    }
  }

  // === TEXTES ===
  if (sess.flow==='set_description' && sess.step==='text' && msg.text){
    const settings=(await kv.get('settings'))||{}; settings.description=msg.text; await kv.set('settings', settings);
    await adminSessionClear(userId); await send('‚úÖ Description mise √† jour.', chatId, adminTextsKb()); return;
  }
  if (sess.flow==='set_faq' && sess.step==='text' && msg.text){
    const settings=(await kv.get('settings'))||{}; settings.faq=msg.text; await kv.set('settings', settings);
    await adminSessionClear(userId); await send('‚úÖ FAQ mise √† jour.', chatId, adminTextsKb()); return;
  }

  // === BRANDING ===
  if (sess.flow==='set_logo' && sess.step==='wait_media'){
    if (msg.photo?.length){
      const best=msg.photo[msg.photo.length-1]; const url=await getFileUrl(best.file_id);
      if (url){ const settings=(await kv.get('settings'))||{}; settings.logoUrl=url; await kv.set('settings', settings); await adminSessionClear(userId); await send('‚úÖ Logo mis √† jour.', chatId, adminBrandingKb()); return; }
    }
    await send('Envoie une photo pour le logo.', chatId); return;
  }
  if (sess.flow==='set_bg' && sess.step==='wait_media'){
    if (msg.photo?.length){
      const best=msg.photo[msg.photo.length-1]; const url=await getFileUrl(best.file_id);
      if (url){ const settings=(await kv.get('settings'))||{}; settings.bgUrl=url; await kv.set('settings', settings); await adminSessionClear(userId); await send('‚úÖ Fond d‚Äô√©cran mis √† jour.', chatId, adminBrandingKb()); return; }
    }
    await send('Envoie une photo pour le fond d‚Äô√©cran.', chatId); return;
  }
  if (sess.flow==='set_name' && sess.step==='ask' && msg.text){
    const settings=(await kv.get('settings'))||{}; settings.shopName=msg.text.trim(); await kv.set('settings', settings);
    await adminSessionClear(userId); await send('‚úÖ Nom de la boutique mis √† jour.', chatId, adminBrandingKb()); return;
  }

  // === CHANNELS ===
  if (sess.flow==='channels' && sess.step==='menu' && msg.text){
    const settings=(await kv.get('settings'))||{}; settings.channels = Array.isArray(settings.channels)?settings.channels:[];
    const t = msg.text.trim();
    if (t.toLowerCase().startsWith('supprimer ')){
      const ch = t.slice(10).trim();
      settings.channels = settings.channels.filter(c=>c!==ch);
      await kv.set('settings', settings);
      await send(`Supprim√©: ${ch}\nActuels: ${settings.channels.join(', ')||'(aucun)'}`, chatId);
    } else if (t.startsWith('@')) {
      if (!settings.channels.includes(t)) settings.channels.push(t);
      await kv.set('settings', settings);
      await send(`Ajout√©: ${t}\nActuels: ${settings.channels.join(', ')}`, chatId);
    } else {
      await send('Format inconnu. Envoie @canal pour ajouter, ou "supprimer @canal".', chatId);
    }
    return;
  }

  // === CONTACT ===
  if (sess.flow==='set_contact' && sess.step==='ask' && msg.text){
    const settings=(await kv.get('settings'))||{}; settings.contactUsername=msg.text.replace(/^@/,''); await kv.set('settings', settings);
    await adminSessionClear(userId); await send('‚úÖ Contact mis √† jour.', chatId, adminContactKb()); return;
  }

  // === ADMINS ===
  if (sess.flow==='admins' && sess.step==='add' && msg.text){
    const id = String(msg.text.trim());
    const settings=(await kv.get('settings'))||{}; settings.admins = Array.isArray(settings.admins)?settings.admins:[];
    if (!settings.admins.includes(id)) settings.admins.push(id);
    await kv.set('settings', settings);
    await adminSessionClear(userId); await send('‚úÖ Admin ajout√©.', chatId, adminAdminsKb()); return;
  }
  if (sess.flow==='admins' && sess.step==='remove' && msg.text){
    const id = String(msg.text.trim());
    const settings=(await kv.get('settings'))||{}; settings.admins = (settings.admins||[]).filter(x=>x!==id);
    await kv.set('settings', settings);
    await adminSessionClear(userId); await send('‚úÖ Admin retir√©.', chatId, adminAdminsKb()); return;
  }
}

/** === Rapports (menu + helpers) === **/
function adminReportsKb(){
  return [
    [{ text:'Aujourdhui', callback_data:'admin:reports:range:today' }],
    [{ text:'Semaine',    callback_data:'admin:reports:range:week'  }],
    [{ text:'Mois',       callback_data:'admin:reports:range:month' }],
    [{ text:'Annee',      callback_data:'admin:reports:range:year'  }],
    [{ text:'Retour',     callback_data:'admin:root' }]
  ];
}
function startOfToday(){const tz='Europe/Paris';const now=new Date();const local=new Date(now.toLocaleString('en-US',{timeZone:tz}));local.setHours(0,0,0,0);const offset=local.getTime()-new Date(local.toLocaleString('en-US',{timeZone:'UTC'})).getTime();return local.getTime()-offset;}
function startOfWeek(){const tz='Europe/Paris';const now=new Date();const local=new Date(now.toLocaleString('en-US',{timeZone:tz}));const day=(local.getDay()+6)%7;local.setHours(0,0,0,0);local.setDate(local.getDate()-day);const offset=local.getTime()-new Date(local.toLocaleString('en-US',{timeZone:'UTC'})).getTime();return local.getTime()-offset;}
function startOfMonth(){const tz='Europe/Paris';const now=new Date();const local=new Date(now.toLocaleString('en-US',{timeZone:tz}));local.setHours(0,0,0,0);local.setDate(1);const offset=local.getTime()-new Date(local.toLocaleString('en-US',{timeZone:'UTC'})).getTime();return local.getTime()-offset;}
function startOfYear(){const tz='Europe/Paris';const now=new Date();const local=new Date(now.toLocaleString('en-US',{timeZone:tz}));local.setHours(0,0,0,0);local.setMonth(0,1);const offset=local.getTime()-new Date(local.toLocaleString('en-US',{timeZone:'UTC'})).getTime();return local.getTime()-offset;}
function rangeTs(kind){
  if (kind==='today') return startOfToday();
  if (kind==='week')  return startOfWeek();
  if (kind==='month') return startOfMonth();
  if (kind==='year')  return startOfYear();
  return 0;
}
function fmtEUR(n){ return new Intl.NumberFormat('fr-FR',{style:'currency', currency:'EUR'}).format(Number(n||0)); }
function fmtDate(ts){
  try{
    return new Date(ts||Date.now()).toLocaleString('fr-FR',{timeZone:'Europe/Paris',year:'numeric',month:'2-digit',day:'2-digit',hour:'2-digit',minute:'2-digit',second:'2-digit'});
  }catch(_){ return new Date(ts||Date.now()).toISOString(); }
}
function orderLine(o){
  const items=(o && o.cart && o.cart.items ? o.cart.items : []).map(i=>String(i.name)+(i.variantLabel?(' ('+i.variantLabel+')'):(i.unit?(' ('+i.unit+')'):''))+' x '+String(i.qty)).join(', ') || '(vide)';
  const d=o && o.delivery ? o.delivery : {};
  const name=[d.firstname||'', d.lastname||''].filter(Boolean).join(' ').trim();
  const addr=[d.address1||'', [d.postalCode||'', d.city||''].filter(Boolean).join(' '), d.country||''].filter(Boolean).join(', ') || '-';
  return [
    '<b>'+o.id+'</b> ‚Ä¢ '+fmtDate(o.ts),
    'Produits: '+items,
    'Paiement: '+(o.payment||'-'),
    'Total: '+fmtEUR((o.totals&&o.totals.cash)||0)+' (cash) ‚Ä¢ '+fmtEUR((o.totals&&o.totals.crypto)||0)+' (crypto)',
    'Adresse: '+(name?name+', ':'')+addr
  ].join('\n');
}
function aggregate(list){let cash=0, crypto=0, count=0;for(let i=0;i<list.length;i++){const o=list[i];if(!o) continue;count++;if(o.payment==="cash"){cash+=Number(o?.totals?.cash||0);}else if(o.payment==="crypto"){crypto+=Number(o?.totals?.crypto||0);}}return {cash,crypto,count};}
async function handleReports(chatId, kind){
  const labels = {today:'Aujourd‚Äôhui', week:'Semaine', month:'Mois', year:'Ann√©e'};
  const since = rangeTs(kind);
  const v2 = (await kv.get('orders_v2')) || [];
  const v1 = (await kv.get('orders')) || [];
  const seen = new Set();
  const all = [...v1, ...v2].filter(o => {
    if (!o || !o.id) return true;
    if (seen.has(o.id)) return false;
    seen.add(o.id);
    return true;
  });
  const list = all.filter(o => Number(o.ts||0) >= since).sort((a,b)=>Number(b.ts)-Number(a.ts));

  if (!list.length){
    await send(`Aucune commande pour la p√©riode ¬´ ${labels[kind]||kind} ¬ª.`, chatId, adminReportsKb());
    return;
  }

  const agg = aggregate(list);
  const header =
    `<b>üìà Rapports ‚Äî ${labels[kind]||kind}</b>\n` +
    `Total commandes: ${agg.count}\n` +
    `CA: ${fmtEUR(agg.cash)} (cash) ‚Ä¢ ${fmtEUR(agg.crypto)} (crypto)\n`;

  let msg = header + '\n' + list.map(orderLine).join('\n\n');

  const MAX = 3800;
  if (msg.length > MAX) {
    let out = header + '\n';
    for (const line of list.map(orderLine)) {
      if (out.length + line.length + 2 > MAX) break;
      out += line + '\n\n';
    }
    msg = out.trimEnd() + '\n\n‚Ä¶(tronqu√©)';
  }

  await send(msg, chatId, adminReportsKb());
}
// === end Reports block ===

// --- Patch helpers (data only) ---
async function handleVersion(chatId){
  try {
    const codeV = process.env.APP_VERSION || 'n/a';
    const dataV = await currentDataVersion();
    await send(`Code: ${codeV}\nData: ${dataV}`, chatId);
  } catch(e){ await send('Version error: '+(e&&e.message||e), chatId); }
}
async function handleRollback(chatId, adminId, target){
  try {
    const r = await rollback(target, String(adminId));
    await send(`Rollback OK ‚Üí ${r.restoredTo}`, chatId);
  } catch(e){ await send('Rollback FAIL: '+(e&&e.message||e), chatId); }
}
async function handlePatchDocument(msg){
  const chatId = msg.chat.id; const userId = msg.from.id;
  try {
    const settings = (await kv.get('settings')) || {};
    if (!isAdmin(userId, settings)) { await send('Acc√®s admin requis.', chatId); return; }

    if (!msg.document || !msg.document.file_id) {
      await send('Patch error: document manquant.', chatId);
      return;
    }

    await send('R√©cup√©ration du fichier‚Ä¶', chatId);
    const fid = msg.document.file_id;
    const url = await getFileUrl(fid);
    if (!url) { await send('Patch error: URL de fichier introuvable.', chatId); return; }

    const buf = await axios.get(url, { responseType:'arraybuffer' }).then(r=>Buffer.from(r.data));
    let manifest;
    try { manifest = JSON.parse(buf.toString('utf8')); }
    catch(e){ await send('Patch error: JSON invalide ('+(e && e.message || e)+')', chatId); return; }

    await send('Preview en cours‚Ä¶', chatId);
    let p;
    try {
      p = await preview(manifest, PATCH_SECRET);
    } catch(e){
      await send('Patch error (preview): '+prettyErr(e), chatId);
      return;
    }

    await send(
      'PREVIEW OK\n'
      + (p.summary||'') + '\n'
      + 'Current: '+(p.currentVersion||'?')+'\n'
      + 'Keys: '+((p.willWriteKeys||[]).join(', ')||'(aucune)'),
      chatId
    , null, true);

    await send('Application du patch‚Ä¶', chatId);
    try {
      await apply(manifest, String(userId), PATCH_SECRET);
    } catch(e){
      await send('Patch error (apply): '+prettyErr(e), chatId);
      return;
    }

    try {
      const hist = (await kv.get('patch:history')) || [];
      hist.push({ at: Date.now(), from: (p && p.currentVersion)||null, to: manifest.version||null, by: String(userId) });
      await kv.set('patch:history', hist);
    } catch(_) {}

    await send('Patch applied. Backup: backup:'+String(manifest.version||'?'), chatId);
    await adminSessionSet(userId,{ flow:'patch', step:'applied' });

    if (manifest.upgrade === true) {
      const ok = await triggerUpgrade();
      await send(ok ? "Code upgrade d√©clench√© (Vercel)" : "Upgrade non d√©clench√© (hook absent ou erreur)", chatId);
    } else {
      await send('Tu peux lancer un Upgrade si besoin.', chatId, adminPatchesKb(true));
    }
  } catch(e){
    await send('Patch error: '+prettyErr(e), chatId);
  }
}

async function handleUpgrade(chatId, adminId){
  const settings = (await kv.get('settings')) || {};
  if (!isAdmin(adminId, settings)) { await send('Acc√®s admin requis.', chatId); return; }
  try {
    const ok = await triggerUpgrade();
    await send(ok ? 'üöÄ Redeploy demand√© √† Vercel.' : '‚ö†Ô∏è VERCEL_DEPLOY_HOOK_URL manquant ou erreur.', chatId);
  } catch(e){
    await send('Upgrade error: ' + (e && e.message || e), chatId);
  }
}

async function triggerUpgrade(){
  try {
    const url = process.env.VERCEL_DEPLOY_HOOK_URL;
    if (!url || !/^https?:\/\//.test(url)) return false;
    await axios.post(url, {}); // simple ping
    return true;
  } catch(_) { return false; }
}
